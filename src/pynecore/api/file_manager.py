"""
File management utilities for API operations.
"""

from pathlib import Path
from typing import Optional, Dict, Any, List
import shutil
from datetime import datetime
import json


class FileManager:
    """
    Manages file operations for API compilation results.
    """

    def __init__(self, output_dir: Optional[Path] = None, max_log_files: int = 10):
        """
        Initialize file manager.

        :param output_dir: Output directory for file operations (defaults to current directory / "output")
        :param max_log_files: Maximum number of log files to keep
        """
        self.output_dir = output_dir or (Path.cwd() / "output")
        self.backup_dir = self.output_dir / "backups"
        self.log_dir = self.output_dir / "logs"
        self.max_log_files = max_log_files

    def save_compiled_code(
            self,
            compiled_code: str,
            script_path: Path,
            custom_output: Optional[Path] = None
    ) -> Path:
        """
        Save compiled Python code to file.

        :param compiled_code: The compiled Python code
        :param script_path: Path to the original Pine Script file
        :param custom_output: Optional custom output path
        :return: Path to the saved file
        """
        # Determine output path
        if custom_output:
            output_path = custom_output
        else:
            output_path = self.generate_output_path(script_path)

        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Create backup if file exists
        if output_path.exists():
            self.backup_existing_file(output_path)

        # Write compiled code to file
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(compiled_code)
            return output_path
        except Exception as e:
            raise OSError(f"Failed to write compiled code to {output_path}: {e}")

    def generate_output_path(self, script_path: Path, custom_output: Optional[Path] = None) -> Path:
        """
        Generate output path for compiled script.

        :param script_path: Path to the original Pine Script file
        :param custom_output: Optional custom output path
        :return: Path for the output Python file
        """
        if custom_output:
            return custom_output

        # Generate output path in output directory
        filename = script_path.stem + ".py"
        return self.output_dir / filename

    @staticmethod
    def save_compiled_script(
            compiled_code: str,
            output_path: Path,
            original_script_path: Optional[Path] = None,
            metadata: Optional[Dict[str, Any]] = None
    ) -> Path:
        """
        Save compiled Python code to file.

        :param compiled_code: The compiled Python code
        :param output_path: Path where to save the compiled code
        :param original_script_path: Path to the original Pine Script file
        :param metadata: Additional metadata to include in comments
        :return: Path to the saved file
        :raises OSError: If file cannot be written
        """
        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Prepare file content with metadata header
        content_lines = [
            '"""',
            'Compiled Python code from Pine Script',
            'Generated by PyneCore API client',
            ''
        ]

        # Add metadata header as comments

        if original_script_path:
            content_lines.append(f'Original file: {original_script_path}')

        content_lines.append(f'Compiled at: {datetime.now().isoformat()}')

        if metadata:
            content_lines.append('')
            content_lines.append('Compilation metadata:')
            for key, value in metadata.items():
                content_lines.append(f'  {key}: {value}')

        content_lines.append('"""')
        content_lines.append('')
        content_lines.append(compiled_code)

        # Write to file
        content = '\n'.join(content_lines)

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return output_path
        except Exception as e:
            raise OSError(f"Failed to write compiled script to {output_path}: {e}")

    @staticmethod
    def backup_existing_file(file_path: Path) -> Optional[Path]:
        """
        Create a backup of an existing file.

        :param file_path: Path to the file to backup
        :return: Path to the backup file, or None if original file doesn't exist
        """
        if not file_path.exists():
            return None

        # Generate backup filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = file_path.with_suffix(f".{timestamp}.backup{file_path.suffix}")

        try:
            shutil.copy2(file_path, backup_path)
            return backup_path
        except Exception as e:
            raise OSError(f"Failed to create backup of {file_path}: {e}")

    @staticmethod
    def get_output_path(input_path: Path, output_dir: Optional[Path] = None) -> Path:
        """
        Generate appropriate output path for compiled script.

        :param input_path: Path to the input Pine Script file
        :param output_dir: Optional output directory (defaults to same as input)
        :return: Path for the output Python file
        """
        if output_dir:
            # Use specified output directory with input filename
            return output_dir / input_path.with_suffix('.py').name
        else:
            # Use same directory as input, change extension to .py
            return input_path.with_suffix('.py')

    @staticmethod
    def save_compilation_log(
            log_data: Dict[str, Any],
            log_path: Optional[Path] = None
    ) -> Path:
        """
        Save compilation log with metadata.

        :param log_data: Dictionary containing compilation log data
        :param log_path: Optional path for log file (defaults to .pynecore/logs/)
        :return: Path to the saved log file
        """
        if log_path is None:
            log_dir = Path.home() / ".pynecore" / "logs"
            log_dir.mkdir(parents=True, exist_ok=True)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_path = log_dir / f"compilation_{timestamp}.json"

        # Add timestamp to log data
        log_data_with_timestamp = {
            "timestamp": datetime.now().isoformat(),
            **log_data
        }

        try:
            with open(log_path, 'w', encoding='utf-8') as f:
                json.dump(log_data_with_timestamp, f, indent=2, default=str)
            return log_path
        except Exception as e:
            raise OSError(f"Failed to write compilation log to {log_path}: {e}")

    @staticmethod
    def clean_old_logs(max_age_days: int = 30) -> List[Path]:
        """
        Clean old compilation logs.

        :param max_age_days: Maximum age of logs to keep in days
        :return: List of paths to deleted log files
        """
        log_dir = Path.home() / ".pynecore" / "logs"
        if not log_dir.exists():
            return []

        deleted_files = []
        cutoff_time = datetime.now().timestamp() - (max_age_days * 24 * 60 * 60)

        try:
            for log_file in log_dir.glob("compilation_*.json"):
                if log_file.stat().st_mtime < cutoff_time:
                    log_file.unlink()
                    deleted_files.append(log_file)
        except Exception:  # noqa
            # Log cleanup is not critical, so we don't raise
            pass

        return deleted_files

    @staticmethod
    def validate_pine_script(script_path: Path) -> bool:
        """
        Basic validation of Pine Script file.

        :param script_path: Path to Pine Script file
        :return: True if file appears to be a valid Pine Script
        :raises FileNotFoundError: If script file doesn't exist
        :raises OSError: If file cannot be read
        """
        if not script_path.exists():
            raise FileNotFoundError(f"Script file not found: {script_path}")

        try:
            with open(script_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Basic Pine Script validation
            # Check for version directive
            has_version = any(
                line.strip().startswith('//@version') or line.strip().startswith('// @version')
                for line in content.split('\n')[:10]  # Check first 10 lines
            )

            # Check for common Pine Script functions/keywords
            pine_keywords = [
                'indicator(', 'strategy(', 'library(',
                'plot(', 'plotshape(', 'plotchar(',
                'ta.', 'math.', 'str.', 'array.', 'matrix.',
                'input.', 'request.'
            ]

            has_pine_syntax = any(keyword in content for keyword in pine_keywords)

            return has_version or has_pine_syntax

        except Exception as e:
            raise OSError(f"Failed to read script file {script_path}: {e}")

    @staticmethod
    def get_script_info(script_path: Path) -> Dict[str, Any]:
        """
        Extract basic information from Pine Script file.

        :param script_path: Path to Pine Script file
        :return: Dictionary with script information
        """
        info = {
            "path": str(script_path),
            "name": script_path.name,
            "size": 0,
            "modified": None,
            "version": None,
            "type": "unknown"
        }

        try:
            stat = script_path.stat()
            info["size"] = stat.st_size
            info["modified"] = datetime.fromtimestamp(stat.st_mtime).isoformat()

            with open(script_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Extract version
            for line in content.split('\n')[:10]:
                line = line.strip()
                if line.startswith('//@version') or line.startswith('// @version'):
                    version_part = line.split('version')[-1].strip()
                    info["version"] = version_part
                    break

            # Determine script type
            if 'indicator(' in content:
                info["type"] = "indicator"
            elif 'strategy(' in content:
                info["type"] = "strategy"
            elif 'library(' in content:
                info["type"] = "library"

        except Exception:  # noqa
            # If we can't read the file, return basic info
            pass

        return info
