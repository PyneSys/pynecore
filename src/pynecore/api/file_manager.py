"""File management utilities for API operations."""

import os
import shutil
from pathlib import Path
from typing import Optional, Dict, Any, List
from datetime import datetime
import shutil
from datetime import datetime
import json


class FileManager:
    """Manages file operations for API compilation results."""
    
    def __init__(self, output_dir: Optional[Path] = None, max_log_files: int = 10):
        """Initialize file manager.
        
        Args:
            output_dir: Output directory for file operations (defaults to current directory / "output")
            max_log_files: Maximum number of log files to keep
        """
        self.output_dir = output_dir or (Path.cwd() / "output")
        self.backup_dir = self.output_dir / "backups"
        self.log_dir = self.output_dir / "logs"
        self.max_log_files = max_log_files
    
    def save_compiled_code(
        self,
        compiled_code: str,
        script_path: Path,
        custom_output: Optional[Path] = None
    ) -> Path:
        """Save compiled Python code to file.
        
        Args:
            compiled_code: The compiled Python code
            script_path: Path to the original Pine Script file
            custom_output: Optional custom output path
            
        Returns:
            Path to the saved file
        """
        # Determine output path
        if custom_output:
            output_path = custom_output
        else:
            output_path = self.generate_output_path(script_path)
        
        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Create backup if file exists
        if output_path.exists():
            self.backup_existing_file(output_path)
        
        # Write compiled code to file
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(compiled_code)
            return output_path
        except Exception as e:
             raise OSError(f"Failed to write compiled code to {output_path}: {e}")
    
    def generate_output_path(self, script_path: Path, custom_output: Optional[Path] = None) -> Path:
        """Generate output path for compiled script.
        
        Args:
            script_path: Path to the original Pine Script file
            custom_output: Optional custom output path
            
        Returns:
            Path for the output Python file
        """
        if custom_output:
            return custom_output
        
        # Generate output path in output directory
        filename = script_path.stem + ".py"
        return self.output_dir / filename
    

    
    def save_compiled_script(
        self,
        compiled_code: str,
        output_path: Path,
        original_script_path: Optional[Path] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Path:
        """Save compiled Python code to file.
        
        Args:
            compiled_code: The compiled Python code
            output_path: Path where to save the compiled code
            original_script_path: Path to the original Pine Script file
            metadata: Additional metadata to include in comments
            
        Returns:
            Path to the saved file
            
        Raises:
            OSError: If file cannot be written
        """
        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Prepare file content with metadata header
        content_lines = []
        
        # Add metadata header as comments
        content_lines.append('"""')
        content_lines.append('Compiled Python code from Pine Script')
        content_lines.append('Generated by PyneCore API client')
        content_lines.append('')
        
        if original_script_path:
            content_lines.append(f'Original file: {original_script_path}')
        
        content_lines.append(f'Compiled at: {datetime.now().isoformat()}')
        
        if metadata:
            content_lines.append('')
            content_lines.append('Compilation metadata:')
            for key, value in metadata.items():
                content_lines.append(f'  {key}: {value}')
        
        content_lines.append('"""')
        content_lines.append('')
        content_lines.append(compiled_code)
        
        # Write to file
        content = '\n'.join(content_lines)
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return output_path
        except Exception as e:
            raise OSError(f"Failed to write compiled script to {output_path}: {e}")
    
    def backup_existing_file(self, file_path: Path) -> Optional[Path]:
        """Create a backup of an existing file.
        
        Args:
            file_path: Path to the file to backup
            
        Returns:
            Path to the backup file, or None if original file doesn't exist
        """
        if not file_path.exists():
            return None
        
        # Generate backup filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = file_path.with_suffix(f".{timestamp}.backup{file_path.suffix}")
        
        try:
            shutil.copy2(file_path, backup_path)
            return backup_path
        except Exception as e:
            raise OSError(f"Failed to create backup of {file_path}: {e}")
    
    def get_output_path(self, input_path: Path, output_dir: Optional[Path] = None) -> Path:
        """Generate appropriate output path for compiled script.
        
        Args:
            input_path: Path to the input Pine Script file
            output_dir: Optional output directory (defaults to same as input)
            
        Returns:
            Path for the output Python file
        """
        if output_dir:
            # Use specified output directory with input filename
            return output_dir / input_path.with_suffix('.py').name
        else:
            # Use same directory as input, change extension to .py
            return input_path.with_suffix('.py')
    
    def save_compilation_log(
        self,
        log_data: Dict[str, Any],
        log_path: Optional[Path] = None
    ) -> Path:
        """Save compilation log with metadata.
        
        Args:
            log_data: Dictionary containing compilation log data
            log_path: Optional path for log file (defaults to .pynecore/logs/)
            
        Returns:
            Path to the saved log file
        """
        if log_path is None:
            log_dir = Path.home() / ".pynecore" / "logs"
            log_dir.mkdir(parents=True, exist_ok=True)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            log_path = log_dir / f"compilation_{timestamp}.json"
        
        # Add timestamp to log data
        log_data_with_timestamp = {
            "timestamp": datetime.now().isoformat(),
            **log_data
        }
        
        try:
            with open(log_path, 'w', encoding='utf-8') as f:
                json.dump(log_data_with_timestamp, f, indent=2, default=str)
            return log_path
        except Exception as e:
            raise OSError(f"Failed to write compilation log to {log_path}: {e}")
    
    def clean_old_logs(self, max_age_days: int = 30) -> List[Path]:
        """Clean old compilation logs.
        
        Args:
            max_age_days: Maximum age of logs to keep in days
            
        Returns:
            List of paths to deleted log files
        """
        log_dir = Path.home() / ".pynecore" / "logs"
        if not log_dir.exists():
            return []
        
        deleted_files = []
        cutoff_time = datetime.now().timestamp() - (max_age_days * 24 * 60 * 60)
        
        try:
            for log_file in log_dir.glob("compilation_*.json"):
                if log_file.stat().st_mtime < cutoff_time:
                    log_file.unlink()
                    deleted_files.append(log_file)
        except Exception as e:
            # Log cleanup is not critical, so we don't raise
            pass
        
        return deleted_files
    
    def validate_pine_script(self, script_path: Path) -> bool:
        """Basic validation of Pine Script file.
        
        Args:
            script_path: Path to Pine Script file
            
        Returns:
            True if file appears to be a valid Pine Script
            
        Raises:
            FileNotFoundError: If script file doesn't exist
            OSError: If file cannot be read
        """
        if not script_path.exists():
            raise FileNotFoundError(f"Script file not found: {script_path}")
        
        try:
            with open(script_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Basic Pine Script validation
            # Check for version directive
            has_version = any(
                line.strip().startswith('//@version') or line.strip().startswith('// @version')
                for line in content.split('\n')[:10]  # Check first 10 lines
            )
            
            # Check for common Pine Script functions/keywords
            pine_keywords = [
                'indicator(', 'strategy(', 'library(',
                'plot(', 'plotshape(', 'plotchar(',
                'ta.', 'math.', 'str.', 'array.', 'matrix.',
                'input.', 'request.'
            ]
            
            has_pine_syntax = any(keyword in content for keyword in pine_keywords)
            
            return has_version or has_pine_syntax
            
        except Exception as e:
            raise OSError(f"Failed to read script file {script_path}: {e}")
    
    def get_script_info(self, script_path: Path) -> Dict[str, Any]:
        """Extract basic information from Pine Script file.
        
        Args:
            script_path: Path to Pine Script file
            
        Returns:
            Dictionary with script information
        """
        info = {
            "path": str(script_path),
            "name": script_path.name,
            "size": 0,
            "modified": None,
            "version": None,
            "type": "unknown"
        }
        
        try:
            stat = script_path.stat()
            info["size"] = stat.st_size
            info["modified"] = datetime.fromtimestamp(stat.st_mtime).isoformat()
            
            with open(script_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract version
            for line in content.split('\n')[:10]:
                line = line.strip()
                if line.startswith('//@version') or line.startswith('// @version'):
                    version_part = line.split('version')[-1].strip()
                    info["version"] = version_part
                    break
            
            # Determine script type
            if 'indicator(' in content:
                info["type"] = "indicator"
            elif 'strategy(' in content:
                info["type"] = "strategy"
            elif 'library(' in content:
                info["type"] = "library"
            
        except Exception:
            # If we can't read the file, return basic info
            pass
        
        return info